#+title: Studies
#+author: Me
#+date: 2021-07-31

Org is a highly flexible structured plain text file format, composed of a few simple, yet versatile,
structures - constructed to be both simple enough for the novice and powerful enough for the expert.

Tools I want to get better during august:

- [] F#
- [] Emacs
- [] Git

---
Started 2021-08:

* TODO F# docs

** Functions

   Functions are the fundamental unit of program execution in any programming language. In F#,
   all functions are considered values; in fact, they are known as /function values/.

   #+BEGIN_SRC fsharp
     // Non-recursive function definition
     let [inline] function-name parameter-list [: return-type] = function-body
     // Recursive function definition
     let rec function-name parameter-list = recursive-function body
   #+END_SRC

   *Scope*

   At any level of scope other than module scope, it is not an error to reuse a value or function
   name. If you reuse a name, the name declared later shadows the name declared earlier. However,
   at the top level scope in a module, names must be unique.

   *Partial application of arguments*

   If you supply fewer than the specified number of arguments, you create a new function that
   expects the remaining arguments. This method of handling arguments is referred to as /currying/
   and is characteristic of functional programming languages like F#.

   #+BEGIN_SRC fsharp
     let cylinderVolume (radius: float) (length: float) : float =
	 let pi = 3.14159
	 length * pi * radius * radius
     let smallPipeRadius = 2.0
     let bigPipeRadius = 3.0
     let smallPipeVolume = cylinderVolume smallPipeRadius
     let bigPipeVolume = cylinderVolume bigPipeRadius
   #+END_SRC

   Because functions are values, they can be used as arguments to other functions or in other
   contexts where values are used.

   *Lambda expressions*

   A /lambda expression/ in an unnamed function.

   #+BEGIN_SRC fsharp
     let apply (fn: int -> int) value = fn value
     let lambdaFun = fun x -> x + 1
     apply lambdaFun 2
     // result: 3
   #+END_SRC

   *Function composition and pipelining*

   The composition of two functions *fn1* and *fn2* is another function that represents the
   application of *fn1* followed the application of *fn2*.

   #+BEGIN_SRC fsharp
     let fn1 x = x + 1
     let fn2 y = y * 2
     let compfn = fn1 >> fn2
     let result = compfn 100
     // result: 202
   #+END_SRC

   Pipelining enables function calls to be chained together as successive operations. Pipelining
   works as follows:

   #+BEGIN_SRC fsharp
     let result = 100 |> fn1 |> fn2
     // result: 202
   #+END_SRC

   *Recursive functions*

   For some recursive functions, it is necessary to refactor a more "pure" definition to one that
   is [[https://cs.stackexchange.com/questions/6230/what-is-tail-recursion][tail recursive]]. This prevents unnecessary recomputations.

** Classes

   [[https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/classes][F# docs - Classes]]

   Classes represent the fundamental description of .NET object types; the class is the primary type
   concept that supports object-oriented programming in F#.

* DONE Learning F# (book)
  CLOSED: [2021-08-15 dom 10:02]

The F# compiler -- which is open source -- compiles your programs into IL, which means that you
can use F# code from any .NET compatible language such as C#; and run it on Mono, .NET Core, or the
.NET framework on windows.

[<EntryPoint>] -> This syntax defines a .NET attribute.

| I'll not continue reading this book since its content is not well explained. |

* TODO Emacs docs

  Ref: [[https://orgmode.org/guide][ORG COMPACT GUIDE]]

** TABLES
  Org comes with a fast and intuitive table editor. Spreadsheet-link calculations are supported in
  connection with the Emacs Calc package. [[https://www.gnu.org/software/emacs/manual/html_node/calc/index.html#Top][GNU Emacs calculator]].

  A table is re-aligned automatically each time you press /TAB/ or /RET/ or /C-c C-c/ inside the
  table. /TAB/ also moves to the next field (/RET/ to the next row) and creates new table rows at
  the end of the table or before horizontal lines. The indentation of the table is set by the first
  line.

  #+BEGIN_SRC org
    |Name|Phone|Age|
    |-
    
    + /TAB/
    
    =
    
    | Name | Phone | Age |
    |------+-------+-----|
    |      |       |     |
  #+END_SRC

  When typing text into a field, Org treats /DEL/, /Backspace/, and all character keys in a special
  way, so that inserting and deleting avoids shifting other fields. Also, when typing immediately after
  point was moved into a new field with /TAB/, the field is automatically made blank.

  *Some commands:*

  /C-c C-c/
    Re-align the table without moving point.

  /TAB/
    Re-align the table, move to the next field. Creates a new row if necessary.

  /S-TAB/
    Re-align, move to previous field.

  /RET/
    Re-align the table and move down to next row. Creates a new row if necessary.

  /S-UP/
  /S-DOWN/
  /S-LEFT/
  /S-RIGHT/
    Move a cell up, down, left, and right by swapping with adjacent cell.

  /M-LEFT, M-RIGHT/
    Move the current column left/right.

  /M-S-LEFT/
    Kill the current column.

  /M-S-RIGHT/
    Insert a new column to the left of point position.

  /M-UP, M-DOWN/
    Move the current row up/down.

  /M-S-UP/
    Kill the current row or horizontal line.

  /M-S-DOWN/
    Insert a new row above the current row. With a prefix argument, the line is created below the
    current one.

  /C-c -/
    Insert a horizontal line below current row. With a prefix argument, the line is created above the
    current line.

  /C-c RET/
    Insert a horizontal line below current row, and move the point into the row below that line.

  /C-c ^/
    Sort the table lines in the region. The position of point indicates the column to be used for
    sorting, and the range of lines is the range between the nearest horizontal separator lines, or
    the entire table.
  
** HYPERLINKS

  Org provides links inside a file, external links to other files, and much more. Also, Org
  recognizes plain URIs, possibly wrapped within angle brackets, and activate them as clickable
  links. The general link format, however, looks like this.
   
  #+BEGIN_SRC org
    [[LINK][DESCRIPTION]]
    
    [[LINK]]
  #+END_SRC

  *Some commands:*

  /C-c C-l/
    Insert a link. This prompts for a link to be inserted into the buffer. You can just type a link,
    or use history keys /UP/ and /DOWN/ to access stored links. You will be prompted for the
    description part of the link.
  
  /C-c C-l/
    Edit the invisible /LINK/ part, with the point on the link.

  /C-c C-o/
    Open link at point.

  /C-c &/
    Jump back to a recorded position. A position is recorded by the commands following internal links,
    and by /C-c %/. Using this command several times in direct succession moves through a ring of
    previously recorded positions.

** /TODO ITEMS/

   Org mode does not require TODO lists to live in separate documents. Instead, TODO items are part
   of a notes file, because they usually come up while taking notes.

   Basically, any headline becomes a TODO item when it starts with the word 'TODO':

   #+BEGIN_SRC org
     **** TODO Write letter to Sam Fortune
   #+END_SRC

   You can use TODO keywords to indicate @emph{sequential} working progress states. [[https://orgmode.org/guide/Multi_002dstate-Workflow.html#Multi_002dstate-Workflow][Doc link]].

   *Checkboxes:*

   Every item in a plain list can be made into a checkbox by starting it with the string '[ ]'.
   Checkboxes are not included into the global TODO list, so they are often great to split a task
   into a number of simple steps.

   *Some commands:*

   /C-c C-t/
     Rotate the TODO state of the current item among
     (unmarked) -> TODO -> DONE -> (unmarked)

   /S-RIGHT/
   /S-LEFT/
     Select the following/preceding TODO state, similar to cycling

   /C-c / t/
     View TODO items in a sparse tree. Folds the entire buffer, but shows all TODO items-with not-DONE
     state-and the headings hierarchy above them.

   /M-x org-agenda t/
     Show the global TODO list. Collects the TODO items (with not-DONE states) from all agenda files
     into a single buffer.

   /S-M-RET/
     Insert a new TODO entry below the current one.

* TODO SAFE

  The SAFE acronym is made up of four separate components:

  * Saturn -> for back-end services in F#

      The Saturn library builds on top of the solid foundation of both the F#-friendly Giraffe and the
      high performance, rock-solid ASP.NET Core web server to provide a set of optional abstractions
      which make configuring web applications and constructing complex routes extremely easy to
      achieve.

      Saturn can host RESTful API endpoints, drive static websites or server-generated content, all
      inside an easy-to-learn functional programming model.

  * Azure -> as a hosting platform plus associated platform services
  * Fable -> for running F# in the web browser

      Is an F# to Javascript compiler, designed to produce readable and standard code. Fable allows
      you to create applications for the browser written entirely in F#, whilst also allowing you
      to interact with native Javascript as needed.
  
  * Elmish -> for client-side user interfaces

* DONE [DB] Optimistic vs pessimistic lock
  CLOSED: [2021-08-22 dom 10:53]
  [[https://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking/129397#129397][Discussion on StackOverflow]]

  - Optimistic locking:

    1. Read a record (with version number) ->
    2. Check that the version hasn't changed ->
    3.1 Write the data (uncorrupted hash);
    3.2 Abort the transaction and the user need to restart it (corrupted hash);

    This strategy is most applicable to high volume systems and three-tier architectures where
    you do not necessarily maintain a connection to the database for your session. In this
    situation the client cannot actually maintain database locks as the connections are taken
    from a pool and you may not be using the same connection from one access to the next.

  - Pessimistic locking:

    1. Lock the record for your exclusive use until you have finished it.

    It has much better integrity with than optimistic locking but requires you to be careful with
    your application design to avoid _deadlocks_. To use pessimistic locking you need either a
    direct connection to the database (as would typically be the case in a two tier client server
    application) or an externally available transaction ID that can be used independently of the
    connection.
    
* DONE QEMU + NixOS
  CLOSED: [2021-08-26 qui 21:23]
  With the help of Magueta.

** DONE [[https://www.computerhope.com/jargon/b/bios.htm][BIOS]]
   CLOSED: [2021-08-26 qui 19:08]

   BIOS means short for *Basic Input/Output System*, is a *ROM (Read Only Memory)* chip found on
   motherboards that allows you to access and set up your computer system at the most basic
   level.

   The BIOS includes instructions on how to load basic computer hardware. It also includes a test
   referred to as a POST (Power-On Self-Test) that helps verify the computer meets requirements
   to boot up properly. If the computer does not pass the POST, you head a combination of beeps
   indicating what is malfunctioning in the computer.

   1. POST - Test the computer hardware and make sure no errors exist before loading the OS.
   2. Bootstrap loader - Locate the OS. If a capable OS is located, the BIOS will pass control
      to it.
   3. BIOS drivers - Low-level drivers that give the computer basic operational control over
      your computer's hardware.
   4. BIOS setup or CMOS setup - Configuration program that allows you to configure hardware
      settings including system settings, such as date, time, and computer passwords.

   The BIOS does things like configure the keyboard, mouse, and other hardware, set the system clock, 
   test the memory, and so on. Then it look for a drive and loads the boot loader on the drive, which
   is either an MBR or GPT partition table.
** DONE UEFI
   CLOSED: [2021-08-26 qui 19:08]

   UEFI stands for Unified Extensible Firmware Interface. It is a publicly available specification
   that defines a software interface between an operating system and platform firmware.
   
   UEFI replaces the legacy BIOS firmware interface originally present in all IBM pc's, with most
   UEFI firmware implementations providing support for legacy BIOS services. UEFI can support
   remote diagnostics and repair of computers, even with no operating system installed.
** DONE [[https://www.redhat.com/en/topics/virtualization/what-is-KVM][KVM]]
   CLOSED: [2021-08-26 qui 19:08]

   KVM stands for Kernel-based Virtual Machine. It's an open source virtualization technology
   built into Linux. Specifically, KVM lets you turn Linux into a hypervisor that allows a host
   machine to run multiple, isolated virtual environments called guests or virtual machines (VMs).

   *KVM is part of Linux.*
** DONE [[https://www.qemu.org/][QEMU]]
   CLOSED: [2021-08-26 qui 19:08]

  [[https://qemu-project.gitlab.io/qemu/][Link to the docs.]]

  According to the site, QEMU is a generic and open source machine emulator and virtualizer.

  1. Emulator -

     Hardware or software that enables one computer system (called the host) to behave
     like another computer system (called the guest). An emulator typically enables the host
     system to run software or use peripheral devices designed for the guest system. Emulation
     refers to the ability of a computer program in an electronic device to emulate (or imitate)
     another program or device.
  2. Virtualizer -

     Virtualization means a variety of technologies for managing computer resources
     by providing a software interface, known as an "abstraction layer", between the software
     (operating system and applications) and the hardware. Virtualization turns "physical" RAM
     and storage into "logical" resources.

     2.1. Hardware virtualization -

     This is what most computer people are referring to when they talk about virtualization. It
     partitions the computer's RAM into separate and isolated "virtual machines" (VMs) simulating
     multiple computers within one physical computer. Hardware virtualization enables multiple
     copies of the same or different operating systems to run in the computer and prevents the OS
     and its application in one VM from interfering with the OS and applications in another VM.

     2.2. Network and storage virtualization -

     In a network, virtualization consolidates multiple devices into a logical view so they can
     be managed from a single console. Virtualization also enables multiple storage devices to be
     accessed the same way no matter their type or location.

     2.3. Application virtualization -

     Application virtualization refers to several techniques that make
     running applications protected, flexible and easy to manage.
  
     2.4. OS virtualization -

     Under the control of one operating system, a server is split into
     "containers" that each handle an application.
  
  With this tool it's possible to:
  - Run operating systems for any machine, on any supported architechture.
    It provides a virtual model of an entire machine (CPU, memory and emulated devices) to run
    a guest OS.
  - Run programs for another Linux/BSD target, on any supported architechture.
  - Run KVM and Xen virtual machines with near native performance.

  [[https://www.youtube.com/watch?v=AAfFewePE7c&ab_channel=DenshiVideo][[YouTube - QEMU: A proper guide!]â€‹]]
** DONE Partition information
   CLOSED: [2021-08-26 qui 21:22]

   In this section I'll be sharing other necessary topics to
   understand the complete installation of the NixOS image.
*** Swap memory

    [[https://www.enterprisestorageforum.com/hardware/what-is-memory-swapping/][Ref link.]]

    Memory swapping is a computer techonology that enables an
    operating system to provide more memory to a running application
    or process than is available in physical *random access memory*
    (RAM). When the physical system memory is exhausted, the operating
    system can opt to make use of memory swapping techniques to get
    additional memory.

    Memory swapping works by making use of virtual memory and storage
    space in an approach that provides additional resources when
    required. In short, this additional memory enables the computer to
    run faster and crunch data better.

    With memory swapping, the operating system makes use of storage
    disk space to provide functional equivalent of memory storage
    space.

    The process of memory swapping is managed by an operating system
    or by a virtual machine hypervisor.

    Advantages of memory swapping:

    - More memory: memory swapping is a critical component of memory
management, enabling an operating system to handle requests that would
otherwise overwhelm a system.

    - Continuous operations: swap file memory can be written to disk
in a continuous manner, enabling faster lookup times for operations.

    - System optimization: application processes of lesser importance
and demand can be relegated to swap space, saving the higher
performance physical memory for higher value operations.

    Limitations of memory swapping:

    - Performance: disk storage space, when called up by memory
swapping, does not offer the same performance as physical RAM for
process execution.

    - Disk limitations: swap files are reliant on the stabiity and
availability of storage media, which might not be as stable as system
memory.

    - Capacity: memory swapping is limited by the available swap space
that has been allocated by an operating system or hypervisor.
*** LVM volumes

    In Linux, Logical Volume Manager (LVM) is a device mapper
    framework that provides logical volume management for the Linux
    kernel. Most modern Linux distributions are LVM-aware to the point
    of being able to have their root file systems on a logical volume.
*** Systemd

    [[https://en.wikipedia.org/wiki/Systemd][Reference link.]]

    systemd is a software suite that provides an array of system
    components for Linux operating systems. Its main aim is to unify
    service configuration and behavior across Linux distributions;
    systemd's primary component is a "system and service manager" - an
    init system used to bootstrap user space and manage user
    processes. It also provides replacements for various daemons and
    utilities, including device management, login management, network
    connection management, and event logging. The name systemd adheres
    to the Unix convention of naming daemons by appending the letter d.
*** Software RAID devices

    [[https://en.wikipedia.org/wiki/RAID][Reference link.]]

    RAID stands for "Redundant Array of Inexpensive Disks", is a data
    storage virtualization technology that combines multiple physical
    disk drive components into one or more logical units for the
    purposes of data redundancy, performance improvement, or
    both. This was in contrast to the previous concept of highly
    reliable mainframe disk drives referred to as "single large
    expensive disk" (SLED).
*** UEFI (GPT) x Legacy Boot (MBR)

    [[https://www.freecodecamp.org/news/mbr-vs-gpt-whats-the-difference-between-an-mbr-partition-and-a-gpt-partition-solved/][Reference link.]]

    The main difference between UEFI and legacy boot is that **UEFI** is the 
    latest method of booting a computer that is designed to replace BIOS 
    while the **legacy boot** is the process of booting the computer using
    BIOS firmware.

    Also, UEFI more is recommended because it includes more security features
    (with less complex code) than the legacy BIOS mode.

    GPT and MBR are related to the partition used in the OS.

    Q: So, what's a partition?

    A: Is a virtual division of a hard disk drive (HDD) or a solid state drive
    (SSD). Each partition can vary in size and typically serves a different
    function.

    In Linux there's typically a root partition (`/`), one for swap which helps
    with memory management, and large /home partition. the /home partition is
    similar to the C: partition in Windows in that it's where you install most
    of your programs and store files.

    Program to check the partitions: **GParted**.

    An overview of MBR and GPT partitions

    Before a drive can be divided into individual partitions, it needs to be
    configured to use a specific partition scheme or table.

    A partition table tells the OS how the partitions and data on the drive are
    organized. MBR stands for Master Boot Record, and is a bit of reserved space
    at the beginning of the drive that contains the information about how the
    partitions are organized. The MBR also contains code to launch the OS, and
    it's sometimes called the Boot Loader.

    GPT is an abbreviation of GUID Partition Table, and is a newer standard that's
    slowly replacing MBR. Unlike MBR partition table, GPT stores the data about
    how all the partitions are organized and how to boot the OS throughout the
    drive. That way if one partition is erased or corrupted, it's still possible
    to boot and recover some of the data.

    Some differences:

    * The maximum capacity of MBR partition tables is only about 2 TB. You can use
      a drive that's larger than 2 TB with MBR, but only the first 2 TB of the drive
      will be used. The rest of the storage on the drive will be wasted.

    * In contrast, GPT partition tables offer a maximum capacity of 9.7 ZB, where
      1 ZB = 1 billion TB.

    * MBR partition tables can have a maximum of 4 separate partitions. However,
      one of those partitions can be configured to be an extended partition, which
      is a partition that can be split up into an 23 additional partitions. So the
      absolute maximum number of partitions an MBR partition table can have is 26
      partitions.

    * GPT partition tables allow for up to 128 separate partitions, which is more
      than enough for most real world applications.

    * As MBR is older, it's usually paired with older Legacy BIOS systems, while
      GPT is found on newer UEFI systems. This means that MBR partitions have
      better software and hardware compatibility, though GPT is starting to catch
      up.
** DONE Steps
   CLOSED: [2021-08-26 qui 21:23]
  
  Choose an interface for the system
  - i3wm gaps
  - dwm -> built with C code
  - install the minimum system and install the interface later

  Download the minimal image and configure it to use with QEMU.

  #+BEGIN_SRC bash
    # download the minimal image:
    $ wget https://channels.nixos.org/nixos-21.05/latest-nixos-minimal-x86_64-linux.iso
    # it will download a file named: latest-nixos-minimal-x86_64-linux.iso
    
    # config the image
    # cmd template -> qemu-img create -f qcow2 NOME.img XG
    $ qemu-img create -f qcow2 nixos-test.img 20G
    # command used to create, convert and modify disk images
    # -f:
    #   Stands for format option. qcow2 stands for copy on write 2nd generation.
    
    
    # bootstrap the machine
    # cmd template -> qemu-system-x86_64 -boot d -cdrom image.iso -m 512 -hda mydisk.img
    $ qemu-system-x86_64 -enable-kvm -boot d \
    $ -cdrom latest-nixos-minimal-x86_64-linux.iso \
    $ -m 2G -cpu host -smp 2 -hda nixos-test.img
    # command used to boot an image
    # to get the help use the -h flag
    # -enable-kvm:
    #   Enable KVM full virtualization support. This option is only available if KVM support
    #   is enabled when compiling.
    # -boot
    #   Specify boot order drives as a string of drive letters. Valid drive letters depend on
    #   the target architechture. The x86 PC uses: a, b (floppy 1 and 2), c (first hard disk)
    #   d (first CD-ROM), n-p (Etherboot from network adapter 1-4), hard disk boot is the default.
    # -cdrom
    #   Use file as CD-ROM image (you cannot use -hdc and -cdrom at the same time). You can use
    #   the host CD-ROM by using /dev/cdrom as filename.
    # -m
    #   Set the quantity of RAM.
    # -hda
    #   Use file as hard disk 0, 1, 2 or image.
    
    # start the vm after closing it
    $ qemu-system-x86_64 -enable-kvm -boot d \
    $ -m 2G -cpu host -smp 2 -hda nixos-test.img
  #+END_SRC

  Follow the installation steps provided by the docs. [[https://nixos.org/manual/nixos/stable/index.html#sec-installation][Link here.]]
  
  Some useful keyboard commands:

  - /Ctrl-alt-g/ -> free the mouse from inside the image.
  - /Ctrl-alt-f/ -> toggle switch fullscreen.
* TODO F# async model 
  Produce a presentation about the F# async model. Scheduled presentation date:
  - 2021-09-16.

** Theory

+ The main differences between _Task_ and _Async_ CE
** Examples

+ How to deal with asynchronous code using callbacks
+ How to deal with asynchronous code using modern approachs
* TODO Basic database concepts

- Language used: _Tutorial D_
